# 1.1 Think About Time Reflection

The time management and productivity ideas that I was incredibly interested in while looking through the different resources that we were given were the ideas of meditation, and flow; I decided to delve more into these topics as I felt as though these would be strategies that I would like to employ in my daily routine. Currently, to be honest, I am not great at managing my time. There are a lot of things going on in my personal life that require a portion of my time, as well as the fact that I am actually just terrible with time management. I procrastinated all four years through my undergrad as a result of several factors, and I’m trying to break the habit of only being incredibly productive while half asleep and anxious at 3 in the morning. So as you can see, my currently strategy is actually nonexistent and I need help.

I would like to incorporate mediation into my current routine during Phase 0 because it helps to develop better focus, less anxiety, and more creativity. I would do this by making the habit an incredibly small one at first, as one of the articles suggests just meditating for only two minutes a day. I looked more into how Leo Babauta of Zen Habits suggests starting to meditate, and it honestly just requires a floor to sit on, a quiet area, and a trigger (an already existing habit). Creating a sense of mindfulness through meditation can also result in a state of flow, where one is completely immersed and focused on their activity. This is a state of mediation and is also what many researchers believe to be when we are our happiest. Again, Babauta suggests achieving flow by choosing work you love to do, clearing away distractions, practicing consistently, and enjoying the state of flow. I’m going to try to achieve a state of flow by utilizing “time boxing”, or taking a period of time to work towards the completion of a goal, taking a break to evaluate my progress, and then repeating the time period again until it is complete.

Overall, it appears that many of the ideas that surround the concepts of time management and productivity have repetitive themes that were covered in most of the resources given (which makes the essential points much easier to reduce and incorporate into daily life!). One of the more significant points that was brought up several times was starting very small when beginning to start a habit. BJ Fogg in particular outlined a behavior model that made a lot of sense to me, and kind of came as a revelation regardless of its simplicity. The factors of motivation and ability affect behavior based on whether or not it is able to surpass the activation threshold that triggers the behavior: if you have a high motivation, and the behavior is easy to do, the behavior will definitely be triggered. On the other hand if you have low motivation, the behavior has to be easy to do in order for you to pass the activation threshold whereas if the behavior is incredibly difficult, you must have very high motivation to succeed. Hence, why Fogg suggests starting with an incredibly small task that would be so easy to do that it is triggered no matter what. He also suggests scheduling these behaviors after already existing behaviors in order to trigger the behavior as a natural part of your existing schedule.

I’m going to start both meditating and attempting to achieve a state of flow to see if these ideas help with my time management! I’m going to start with small habits: meditating for two minutes a day after breakfast, and creating conditions for a state of flow during a time box (perhaps I’ll try the pomodoro method?) for at least one challenge this week. I will evaluate how my habits have changed at the end of the week and see if I am more productive!

# 1.2 The Command Line Reflection

A shell a is user interface that interprets user commands via a text shell (command line interpreter) or graphical shell (GUI) and executes these commands to the operating system. Due to the fact that I am a Mac user, I use the program Terminal to run the CLI as it is a kind of terminal “emulator” that, with my understanding, is essentially synonymous with a shell.  There are several different kinds of shells that have different functionalities and syntax, and bash (Bourne-again shell) is one of them. Bash consists of a variety of different features from different shells and is known to be a flexible option for most users as it is a variation of the more basic standard sh (Bourne shell), which was the original Unix shell.

Initially, I think the most challenging element of learning how to use the command line was attempting to get over my pre-conceived notion of how I (as a user) am supposed to interact with the operating system. As a computer user born in the new generation, I am very much used to executing commands through a graphical user interface. While I was going through some of the earlier exercises in the assignment I found myself checking whether or not I was properly use the commands through the GUI instead of using the command line. After going through a few of the exercises I realized that it would be somewhat pointless to not check via the command line, so I stopped checking through the GUI. After becoming more comfortable with the command line and more confident that I was executing commands properly, it because somewhat easier to start absorbing the material more easily.

I was able to successfully use all of the commands that were outlined in the course! Some of the functionality wasn’t completely clear while going through the exercises (particularly in the pipes and redirection section) but I know that they were all executed properly as I received the same prompts as was shown. I’m sure it will become much clearer once I’m actually executing the commands with a real task at hand rather than just doing what the course told me to do.

It seems as though some of the real functionality in using the CLI lies in pipes and redirection (exactly the topic that I found least clear), however also it seems as though just generally knowing how to move through directories and pulling relevant information is something that would occur consistently. I would imagine that commands such as pwd, ls, cd, ../, rmdir, and rm would be used very often in different tasks. I’m sure that grep could also come in handy when attempting to find something specific inside a file. According to man grep, there are different variations of grep which are quite confusing, such as egrep, that handles extended regular expressions, and fgrep, which is both faster than grep and egrep. The crash course itself seemed to be a great introduction to many of the commands that we would be using on a fairly consistent basis, so I'm sure all of these are important to know as we only covered a very limited subset of commands that we are able to execute.

I knew these flashcards would be helpful for something…

pwd: Print working directory! This essentially gives you your location and lets you know which directory you are in.

ls: List directory! This shows you exactly what directories/files are in your current directory.

mv: Move a file or directory! This command allows you to move files and directories to other locations. I also found out that this command is used to rename files.

cd: Change directory! I probably used this command the most while going through all of the exercises. This command allows you to get from one directory to the other by executing cd directory. Also cd alone gets you back to the user directory.

../: This command is used in conjunction with cd in order to move up in a directory path.

touch: Creates a new empty file. That’s pretty much it.

mkdir: Creates a new directory!

less: Allows you to page through a file.

rmdir: Removes directory.

rm: Removes a file, though I also found that it can remove directories (?).

help: I am on a Mac, so I believe this is the window’s command for Mac’s “man”. In either case you can use this command to access help pages to look at more detailed descriptions for each command.

# 1.4 Forking and Cloning Reflection

If you were going to write instructions for a new person on how to create a new repo, fork a repo, and clone a repo, what would they be? Why would you fork a repository as opposed to create a new one?

Creating a new repository is easy! You would simply log into your GitHub account, click on the plus sign next to your profile icon, and click on the “New Repository” drop-down option. This will lead you to a new page where you can name your repository, add an optional description, select whether or not you want the repo to be public/private, and then choose to add a license. After selecting these options, click create repository at the bottom and you’re done!

Forking a repo is even easier: go to the repo’s page, and in the upper-right hand corner below your profile, click on the button that says fork. From there you will be able to select what account to fork the repo to (your account) and you’re finished.

To clone a repo, go to the repo’s page and below the repo settings, you’ll see a URL below “HTTPS clone URL”. Copy this URL, go to the directory in which you would like to clone your repo in terminal, and type “git clone URL”. The repo is now in the indicated directory!

You would likely fork a repository as opposed to creating a new one in order to contribute to a project in which you are collaborating on with other users. As noted earlier in the video describing branching, if you’re working on a specific task for the project, you need to be able to access and add your own branch in the first place! I would imagine that it might also be useful in personal projects where you are editing some portion of code from a repo and building upon it/completely change it just to experiment.

What struggles did you have setting up git and GitHub? What did you learn in the process?

Git and GitHub, thus far, have been deceivingly easy to set up. Having said that, I struggled to overcome that initial hesitation to jump into a topic that I really had absolutely no background knowledge on. Embarrassingly I once thought that GitHub was some online community for elite developers who were doing really advanced developer magic and riding unicorns. I’ve since learned that Git is a great tool to utilize in collaborative settings while working on projects, and that it definitely doesn’t have to be limited to dev work. Setting up a repo, forking repos, and cloning them are likely basic tasks in the world of GitHub, but it has been a great time learning about a topic that will become such an essential part of my life as a dev.